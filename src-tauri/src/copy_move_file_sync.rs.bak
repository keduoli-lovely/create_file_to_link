// use tauri::{command, AppHandle, Emitter};
// use fs_extra::file::{
//     copy_with_progress,
//     move_file_with_progress,
//     CopyOptions as FileCopyOptions,
//     TransitProcess as FileTransit,
// };
// use fs_extra::dir::{ copy_with_progress as copy_dir_with_progress, move_dir_with_progress, CopyOptions as DirCopyOptions, TransitProcess as DirTransit, TransitProcessResult, };

// use serde::Serialize;
// use std::path::PathBuf;

// #[derive(Serialize)]
// pub struct FileResult {
//     old: String,
//     new: String,
// }

// #[derive(Serialize, Clone)]
// struct ProgressPayload {
//     src: String,
//     percent: u64,
// }

// #[command]
// pub fn move_or_copy_files(
//     app: AppHandle,
//     go_list: Vec<String>,
//     is_file: bool,
//     is_copy: bool,
//     to_path: String,
// ) -> Result<Vec<FileResult>, String> {
//     let mut results = Vec::new();

//     for src in go_list {
//         let src_path = PathBuf::from(&src);
//         let file_name = src_path
//             .file_name()
//             .ok_or_else(|| format!("无法获取文件名: {}", src))?;
//         let dest_path = PathBuf::from(&to_path).join(file_name);

//         if is_file {
//             // 文件操作
//             let options = FileCopyOptions::new();
//             let app = app.clone();
//             let src_clone = src.clone();

//             let handler = move |process_info: FileTransit| {
//                 let percent = if process_info.total_bytes > 0 {
//                     process_info.copied_bytes * 100 / process_info.total_bytes
//                 } else {
//                     0
//                 };
//                 let _ = app.emit(
//                     "file-progress",
//                     ProgressPayload {
//                         src: src_clone.clone(),
//                         percent,
//                     },
//                 );
//                 // 文件回调返回 ()
//             };

//             if is_copy {
//                 copy_with_progress(&src_path, &dest_path, &options, handler)
//                     .map_err(|e| format!("拷贝失败 {}: {}", src, e))?;
//             } else {
//                 move_file_with_progress(&src_path, &dest_path, &options, handler)
//                     .map_err(|e| format!("移动失败 {}: {}", src, e))?;
//             }
//         } else {
//             // 目录操作
//             let options = DirCopyOptions::new();
//             let app = app.clone();
//             let src_clone = src.clone();

//             let handler = move |process_info: DirTransit| {
//                 let percent = if process_info.total_bytes > 0 {
//                     process_info.copied_bytes * 100 / process_info.total_bytes
//                 } else {
//                     0
//                 };
//                 let _ = app.emit(
//                     "file-progress",
//                     ProgressPayload {
//                         src: src_clone.clone(),
//                         percent,
//                     },
//                 );
//                 TransitProcessResult::ContinueOrAbort // 目录回调必须返回 TransitProcessResult
//             };

//             if is_copy {
//                 copy_dir_with_progress(&src_path, &dest_path, &options, handler)
//                     .map_err(|e| format!("目录拷贝失败 {}: {}", src, e))?;
//             } else {
//                 move_dir_with_progress(&src_path, &dest_path, &options, handler)
//                     .map_err(|e| format!("目录移动失败 {}: {}", src, e))?;
//             }
//         }

//         results.push(FileResult {
//             old: src.clone(),
//             new: dest_path.to_string_lossy().to_string(),
//         });
//     }

//     Ok(results)
// }

use fs_extra::dir::{
    copy_with_progress as copy_dir_with_progress, move_dir_with_progress,
    CopyOptions as DirCopyOptions, TransitProcess as DirTransit, TransitProcessResult,
};
use fs_extra::file::{
    copy_with_progress, move_file_with_progress, CopyOptions as FileCopyOptions,
    TransitProcess as FileTransit,
};
use serde::Serialize;
use std::path::PathBuf;
use tauri::{command, AppHandle, Emitter};

#[derive(Serialize)]
pub struct FileResult {
    pub old: String,
    pub new: String,
}

#[derive(Serialize, Clone)]
pub struct ProgressPayload {
    pub src: String,
    pub percent: u64,
}

#[command]
pub fn move_or_copy_files(
    app: AppHandle,
    go_list: Vec<String>,
    is_file: bool,
    is_copy: bool,
    to_path: String,
) -> Result<Vec<FileResult>, String> {
    let mut results = Vec::new();

    // 确保目标父目录存在
    std::fs::create_dir_all(&to_path).map_err(|e| format!("创建目标目录失败: {}", e))?;

    for src in go_list {
        let src_path = PathBuf::from(&src);
        let file_name = src_path
            .file_name()
            .ok_or_else(|| format!("无法获取文件名: {}", src))?;
        let dest_path = PathBuf::from(&to_path).join(file_name);

        if is_file {
            // 文件操作
            let mut options = FileCopyOptions::new();
            options.overwrite = true;
            let app = app.clone();
            let src_clone = src.clone();

            let handler = move |process_info: FileTransit| {
                let percent = if process_info.total_bytes > 0 {
                    process_info.copied_bytes * 100 / process_info.total_bytes
                } else {
                    0
                };
                let _ = app.emit(
                    "file-progress",
                    ProgressPayload {
                        src: src_clone.clone(),
                        percent,
                    },
                );

                // 文件回调返回 ()
            };

            if is_copy {
                copy_with_progress(&src_path, &dest_path, &options, handler)
                    .map_err(|e| format!("拷贝失败 {}: {}", src, e))?;
            } else {
                move_file_with_progress(&src_path, &dest_path, &options, handler)
                    .map_err(|e| format!("移动失败 {}: {}", src, e))?;
            }
        } else {
            // 目录操作
            let mut options = DirCopyOptions::new();
            options.overwrite = true;
            let app = app.clone();
            let src_clone = src.clone();

            let handler = move |process_info: DirTransit| {
                let percent = if process_info.total_bytes > 0 {
                    process_info.copied_bytes * 100 / process_info.total_bytes
                } else {
                    0
                };
                let _ = app.emit(
                    "file-progress",
                    ProgressPayload {
                        src: src_clone.clone(),
                        percent,
                    },
                );

                TransitProcessResult::ContinueOrAbort
            };

            if is_copy {
                copy_dir_with_progress(&src_path, &PathBuf::from(&to_path), &options, handler)
                    .map_err(|e| format!("目录拷贝失败 {}: {}", src, e))?;
            } else {
                move_dir_with_progress(&src_path, &PathBuf::from(&to_path), &options, handler)
                    .map_err(|e| format!("目录移动失败 {}: {}", src, e))?;
            }

            results.push(FileResult {
                old: src.clone(),
                new: PathBuf::from(&to_path)
                    .join(src_path.file_name().unwrap())
                    .to_string_lossy()
                    .to_string(),
            });
            continue;
        }

        results.push(FileResult {
            old: src.clone(),
            new: dest_path.to_string_lossy().to_string(),
        });
    }

    Ok(results)
}
